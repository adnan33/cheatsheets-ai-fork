
# Kickstart your ML development
- Model Converters
https://github.com/mikewlange/deep-learning-model-convertor 

....


# cheatsheets-ai
Essential Cheat Sheets for deep learning and machine learning researchers

  - Keras
  - Neural Networks Zoo
  - Numpy
  - Scipy
  - Pandas
  - Scikit-learn
  - Matplotlib
  - Deep Learning Cheat Sheet
  
  
# Neural Network Zoo
The content below I snagged from http://www.asimovinstitute.org/neural-network-zoo/  - go there. Great info. If you are http://www.asimovinstitute.org and don't want this info here, let me know. But i think it's quite helpful. Thanks for sharing!! 


<div class="hentry__inside">	

<div class="hentry__inside">	
<p>With new neural network architectures popping up every now and then, it’s hard to keep track of them all. Knowing all the abbreviations being thrown around (DCIGN, BiLSTM, DCGAN, anyone?) can be a bit overwhelming at first.</p>


<p>So I decided to compose a cheat sheet containing many of those architectures. Most of these are neural networks, some are completely different beasts. Though all of these architectures are presented as novel and unique, when I drew the node structures… their underlying relations started to make more sense.</p>


![neuralnetworks](https://preview.ibb.co/eZm1Na/neuralnetworks.png)


<article id="post-197" class="single-template post-197 post type-post status-publish format-standard has-post-thumbnail hentry category-deep-learning">


<p>One problem with drawing them as node maps: it doesn&#8217;t really show how they&#8217;re used. For example, variational autoencoders (VAE) may look just like autoencoders (AE), but the training process is actually quite different. The use-cases for trained networks differ even more, because VAEs are generators, where you insert noise to get a new sample. AEs, simply map whatever they get as input to the closest training sample they &#8220;remember&#8221;. I should add that this overview is in no way clarifying how each of the different node types work internally (but that&#8217;s a topic for another day).</p>
<p>It should be noted that while most of the abbreviations used are generally accepted, not all of them are. RNNs sometimes refer to recursive neural networks, but most of the time they refer to recurrent neural networks. That&#8217;s not the end of it though, in many places you&#8217;ll find RNN used as placeholder for any recurrent architecture, including LSTMs, GRUs and even the bidirectional variants. AEs suffer from a similar problem from time to time, where VAEs and DAEs and the like are called simply AEs. Many abbreviations also vary in the amount of &#8220;N&#8221;s to add at the end, because you could call it a convolutional neural network but also simply a convolutional network (resulting in CNN or CN).</p>
<p>Composing a complete list is practically impossible, as new architectures are invented all the time. Even if published it can still be quite challenging to find them even if you&#8217;re looking for them, or sometimes you just overlook some. So while this list may provide you with some insights into the world of AI, please, by no means take this list for being comprehensive; especially if you read this post long after it was written.</p>
<p>For each of the architectures depicted in the picture, I wrote a <em>very, very</em> brief description. You may find some of these to be useful if you&#8217;re quite familiar with some architectures, but you aren&#8217;t familiar with a particular one.</p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/ff.png" width="300" /></p>
<p><strong>Feed forward neural networks (FF or FFNN) and perceptrons (P)</strong> are very straight forward, they feed information from the front to the back (input and output, respectively). Neural networks are often described as having layers, where each layer consists of either input, hidden or output cells in parallel. A layer alone never has connections and in general two adjacent layers are fully connected (every neuron form one layer to every neuron to another layer). The simplest somewhat practical network has two input cells and one output cell, which can be used to model logic gates. One usually trains FFNNs through back-propagation, giving the network paired datasets of &#8220;what goes in&#8221; and &#8220;what we want to have coming out&#8221;. This is called supervised learning, as opposed to unsupervised learning where we only give it input and let the network fill in the blanks. The error being back-propagated is often some variation of the difference between the input and the output (like MSE or just the linear difference). Given that the network has enough hidden neurons, it can theoretically always model the relationship between the input and output. Practically their use is a lot more limited but they are popularly combined with other networks to form new networks.</p>
<p><i>Rosenblatt, Frank. &#8220;The perceptron: a probabilistic model for information storage and organization in the brain.&#8221; Psychological review 65.6 (1958): 386.</i><br />
<a style="color:#06c" href="http://www.ling.upenn.edu/courses/cogs501/Rosenblatt1958.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/rbf.png" width="300" /></p>
<p><strong>Radial basis function (RBF)</strong> networks are FFNNs with radial basis functions as activation functions. There&#8217;s nothing more to it. Doesn&#8217;t mean they don&#8217;t have their uses, but most FFNNs with other activation functions don&#8217;t get their own name. This mostly has to do with inventing them at the right time.</p>
<p><i>Broomhead, David S., and David Lowe. Radial basis functions, multi-variable functional interpolation and adaptive networks. No. RSRE-MEMO-4148. ROYAL SIGNALS AND RADAR ESTABLISHMENT MALVERN (UNITED KINGDOM), 1988.</i><br />
<a style="color:#06c" href="http://www.dtic.mil/cgi-bin/GetTRDoc?AD=ADA196234">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/hn.png" width="300" /></p>
<p>A <strong>Hopfield network (HN)</strong> is a network where every neuron is connected to every other neuron; it is a completely entangled plate of spaghetti as even all the nodes function as everything. Each node is input before training, then hidden during training and output afterwards. The networks are trained by setting the value of the neurons to the desired pattern after which the weights can be computed. The weights do not change after this. Once trained for one or more patterns, the network will always converge to one of the learned patterns because the network is only stable in those states. Note that it does not always conform to the desired state (it&#8217;s not a magic black box sadly). It stabilises in part due to the total &#8220;energy&#8221; or &#8220;temperature&#8221; of the network being reduced incrementally during training. Each neuron has an activation threshold which scales to this temperature, which if surpassed by summing the input causes the neuron to take the form of one of two states (usually -1 or 1, sometimes 0 or 1). Updating the network can be done synchronously or more commonly one by one. If updated one by one, a fair random sequence is created to organise which cells update in what order (fair random being all options (n) occurring exactly once every n items). This is so you can tell when the network is stable (done converging), once every cell has been updated and none of them changed, the network is stable (annealed). These networks are often called associative memory because the converge to the most similar state as the input; if humans see half a table we can image the other half, this network will converge to a table if presented with half noise and half a table.</p>
<p><i>Hopfield, John J. &#8220;Neural networks and physical systems with emergent collective computational abilities.&#8221; Proceedings of the national academy of sciences 79.8 (1982): 2554-2558.</i><br />
<a style="color:#06c" href="https://bi.snu.ac.kr/Courses/g-ai09-2/hopfield82.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/mc.png" width="300" /></p>
<p><strong>Markov chains (MC or discrete time Markov Chain, DTMC)</strong> are kind of the predecessors to BMs and HNs. They can be understood as follows: from this node where I am now, what are the odds of me going to any of my neighbouring nodes? They are memoryless (i.e. Markov Property) which means that every state you end up in depends completely on the previous state. While not really a neural network, they do resemble neural networks and form the theoretical basis for BMs and HNs. MC aren&#8217;t always considered neural networks, as goes for BMs, RBMs and HNs. Markov chains aren&#8217;t always fully connected either.</p>
<p><i>Hayes, Brian. &#8220;First links in the Markov chain.&#8221; American Scientist 101.2 (2013): 252.</i><br />
<a style="color:#06c" href="http://www.americanscientist.org/libraries/documents/201321152149545-2013-03Hayes.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/bm.png" width="300" /></p>
<p><strong>Boltzmann machines (BM)</strong> are a lot like HNs, but: some neurons are marked as input neurons and others remain &#8220;hidden&#8221;. The input neurons become output neurons at the end of a full network update. It starts with random weights and learns through back-propagation, or more recently through contrastive divergence (a Markov chain is used to determine the gradients between two informational gains). Compared to a HN, the neurons mostly have binary activation patterns. As hinted by being trained by MCs, BMs are stochastic networks. The training and running process of a BM is fairly similar to a HN: one sets the input neurons to certain clamped values after which the network is set free (it doesn&#8217;t get a sock). While free the cells can get any value and we repetitively go back and forth between the input and hidden neurons. The activation is controlled by a global temperature value, which if lowered lowers the energy of the cells. This lower energy causes their activation patterns to stabilise. The network reaches an equilibrium given the right temperature.</p>
<p><i>Hinton, Geoffrey E., and Terrence J. Sejnowski. &#8220;Learning and releaming in Boltzmann machines.&#8221; Parallel distributed processing: Explorations in the microstructure of cognition 1 (1986): 282-317.</i><br />
<a style="color:#06c" href="https://www.researchgate.net/profile/Terrence_Sejnowski/publication/242509302_Learning_and_relearning_in_Boltzmann_machines/links/54a4b00f0cf256bf8bb327cc.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/rbm.png" width="300" /></p>
<p><strong>Restricted Boltzmann machines (RBM)</strong> are remarkably similar to BMs (surprise) and therefore also similar to HNs. The biggest difference between BMs and RBMs is that RBMs are a better usable because they are more restricted. They don&#8217;t trigger-happily connect every neuron to every other neuron but only connect every different group of neurons to every other group, so no input neurons are directly connected to other input neurons and no hidden to hidden connections are made either. RBMs can be trained like FFNNs with a twist: instead of passing data forward and then back-propagating, you forward pass the data and then backward pass the data (back to the first layer). After that you train with forward-and-back-propagation.</p>
<p><i>Smolensky, Paul. Information processing in dynamical systems: Foundations of harmony theory. No. CU-CS-321-86. COLORADO UNIV AT BOULDER DEPT OF COMPUTER SCIENCE, 1986.</i><br />
<a style="color:#06c" href="http://www.dtic.mil/cgi-bin/GetTRDoc?Location=U2&#038;doc=GetTRDoc.pdf&#038;AD=ADA620727">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/ae.png" width="300" /></p>
<p><strong>Autoencoders (AE)</strong> are somewhat similar to FFNNs as AEs are more like a different use of FFNNs than a fundamentally different architecture. The basic idea behind autoencoders is to encode information (as in compress, not encrypt) automatically, hence the name. The entire network always resembles an hourglass like shape, with smaller hidden layers than the input and output layers. AEs are also always symmetrical around the middle layer(s) (one or two depending on an even or odd amount of layers). The smallest layer(s) is|are almost always in the middle, the place where the information is most compressed (the chokepoint of the network). Everything up to the middle is called the encoding part, everything after the middle the decoding and the middle (surprise) the code. One can train them using backpropagation by feeding input and setting the error to be the difference between the input and what came out. AEs can be built symmetrically when it comes to weights as well, so the encoding weights are the same as the decoding weights.</p>
<p><i>Bourlard, Hervé, and Yves Kamp. &#8220;Auto-association by multilayer perceptrons and singular value decomposition.&#8221; Biological cybernetics 59.4-5 (1988): 291-294.</i><br />
<a style="color:#06c" href="https://pdfs.semanticscholar.org/f582/1548720901c89b3b7481f7500d7cd64e99bd.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/sae.png" width="300" /></p>
<p><strong>Sparse autoencoders (SAE)</strong> are in a way the opposite of AEs. Instead of teaching a network to represent a bunch of information in less &#8220;space&#8221; or nodes, we try to encode information in more space. So instead of the network converging in the middle and then expanding back to the input size, we blow up the middle. These types of networks can be used to extract many small features from a dataset. If one were to train a SAE the same way as an AE, you would in almost all cases end up with a pretty useless identity network (as in what comes in is what comes out, without any transformation or decomposition). To prevent this, instead of feeding back the input, we feed back the input plus a sparsity driver. This sparsity driver can take the form of a threshold filter, where only a certain error is passed back and trained, the other error will be &#8220;irrelevant&#8221; for that pass and set to zero. In a way this resembles spiking neural networks, where not all neurons fire all the time (and points are scored for biological plausibility).</p>
<p><i>Marc’Aurelio Ranzato, Christopher Poultney, Sumit Chopra, and Yann LeCun. &#8220;Efficient learning of sparse representations with an energy-based model.&#8221; Proceedings of NIPS. 2007.</i><br />
<a style="color:#06c" href="https://papers.nips.cc/paper/3112-efficient-learning-of-sparse-representations-with-an-energy-based-model.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/vae.png" width="300" /></p>
<p><strong>Variational autoencoders (VAE)</strong> have the same architecture as AEs but are &#8220;taught&#8221; something else: an approximated probability distribution of the input samples. It&#8217;s a bit back to the roots as they are bit more closely related to BMs and RBMs. They do however rely on Bayesian mathematics regarding probabilistic inference and independence, as well as a re-parametrisation trick to achieve this different representation. The inference and independence parts make sense intuitively, but they rely on somewhat complex mathematics. The basics come down to this: take influence into account. If one thing happens in one place and something else happens somewhere else, they are not necessarily related. If they are not related, then the error propagation should consider that. This is a useful approach because neural networks are large graphs (in a way), so it helps if you can rule out influence from some nodes to other nodes as you dive into deeper layers.</p>
<p><i>Kingma, Diederik P., and Max Welling. &#8220;Auto-encoding variational bayes.&#8221; arXiv preprint arXiv:1312.6114 (2013).</i><br />
<a style="color:#06c" href="https://arxiv.org/pdf/1312.6114v10.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/dae.png" width="300" /></p>
<p><strong>Denoising autoencoders (DAE)</strong> are AEs where we don&#8217;t feed just the input data, but we feed the input data with noise (like making an image more grainy). We compute the error the same way though, so the output of the network is compared to the original input without noise. This encourages the network not to learn details but broader features, as learning smaller features often turns out to be &#8220;wrong&#8221; due to it constantly changing with noise.</p>
<p><i>Vincent, Pascal, et al. &#8220;Extracting and composing robust features with denoising autoencoders.&#8221; Proceedings of the 25th international conference on Machine learning. ACM, 2008.</i><br />
<a style="color:#06c" href="http://machinelearning.org/archive/icml2008/papers/592.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/dbn.png" width="300" /></p>
<p><strong>Deep belief networks (DBN)</strong> is the name given to stacked architectures of mostly RBMs or VAEs. These networks have been shown to be effectively trainable stack by stack, where each AE or RBM only has to learn to encode the previous network. This technique is also known as greedy training, where greedy means making locally optimal solutions to get to a decent but possibly not optimal answer. DBNs can be trained through contrastive divergence or back-propagation and learn to represent the data as a probabilistic model, just like regular RBMs or VAEs. Once trained or converged to a (more) stable state through unsupervised learning, the model can be used to generate new data. If trained with contrastive divergence, it can even classify existing data because the neurons have been taught to look for different features.</p>
<p><i>Bengio, Yoshua, et al. &#8220;Greedy layer-wise training of deep networks.&#8221; Advances in neural information processing systems 19 (2007): 153.</i><br />
<a style="color:#06c" href="https://papers.nips.cc/paper/3048-greedy-layer-wise-training-of-deep-networks.pdf
">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/cnn.png" width="300" /></p>
<p><strong>Convolutional neural networks (CNN or deep convolutional neural networks, DCNN)</strong> are quite different from most other networks. They are primarily used for image processing but can also be used for other types of input such as as audio. A typical use case for CNNs is where you feed the network images and the network classifies the data, e.g. it outputs &#8220;cat&#8221; if you give it a cat picture and &#8220;dog&#8221; when you give it a dog picture. CNNs tend to start with an input &#8220;scanner&#8221; which is not intended to parse all the training data at once. For example, to input an image of 200 x 200 pixels, you wouldn&#8217;t want a layer with 40 000 nodes. Rather, you create a scanning input layer of say 20 x 20 which you feed the first 20 x 20 pixels of the image (usually starting in the upper left corner). Once you passed that input (and possibly use it for training) you feed it the next 20 x 20 pixels: you move the scanner one pixel to the right. Note that one wouldn&#8217;t move the input 20 pixels (or whatever scanner width) over, you&#8217;re not dissecting the image into blocks of 20 x 20, but rather you&#8217;re crawling over it. This input data is then fed through convolutional layers instead of normal layers, where not all nodes are connected to all nodes. Each node only concerns itself with close neighbouring cells (how close depends on the implementation, but usually not more than a few). These convolutional layers also tend to shrink as they become deeper, mostly by easily divisible factors of the input (so 20 would probably go to a layer of 10 followed by a layer of 5). Powers of two are very commonly used here, as they can be divided cleanly and completely by definition: 32, 16, 8, 4, 2, 1. Besides these convolutional layers, they also often feature pooling layers. Pooling is a way to filter out details: a commonly found pooling technique is max pooling, where we take say 2 x 2 pixels and pass on the pixel with the most amount of red. To apply CNNs for audio, you basically feed the input audio waves and inch over the length of the clip, segment by segment. Real world implementations of CNNs often glue an FFNN to the end to further process the data, which allows for highly non-linear abstractions. These networks are called DCNNs but the names and abbreviations between these two are often used interchangeably.</p>
<p><i>LeCun, Yann, et al. &#8220;Gradient-based learning applied to document recognition.&#8221; Proceedings of the IEEE 86.11 (1998): 2278-2324.</i><br />
<a style="color:#06c" href="http://yann.lecun.com/exdb/publis/pdf/lecun-98.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/dn.png" width="300" /></p>
<p><strong>Deconvolutional networks (DN)</strong>, also called inverse graphics networks (IGNs), are reversed convolutional neural networks. Imagine feeding a network the word &#8220;cat&#8221; and training it to produce cat-like pictures, by comparing what it generates to real pictures of cats. DNNs can be combined with FFNNs just like regular CNNs, but this is about the point where the line is drawn with coming up with new abbreviations. They may be referenced as deep deconvolutional neural networks, but you could argue that when you stick FFNNs to the back and the front of DNNs that you have yet another architecture which deserves a new name. Note that in most applications one wouldn&#8217;t actually feed text-like input to the network, more likely a binary classification input vector. Think &lt;0, 1&gt; being cat, &lt;1, 0&gt; being dog and &lt;1, 1&gt; being cat and dog. The pooling layers commonly found in CNNs are often replaced with similar inverse operations, mainly interpolation and extrapolation with biased assumptions (if a pooling layer uses max pooling, you can invent exclusively lower new data when reversing it).</p>
<p><i>Zeiler, Matthew D., et al. &#8220;Deconvolutional networks.&#8221; Computer Vision and Pattern Recognition (CVPR), 2010 IEEE Conference on. IEEE, 2010.</i><br />
<a style="color:#06c" href="http://www.matthewzeiler.com/pubs/cvpr2010/cvpr2010.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/dcign.png" width="300" /></p>
<p><strong>Deep convolutional inverse graphics networks (DCIGN)</strong> have a somewhat misleading name, as they are actually VAEs but with CNNs and DNNs for the respective encoders and decoders. These networks attempt to model &#8220;features&#8221; in the encoding as probabilities, so that it can learn to produce a picture with a cat and a dog together, having only ever seen one of the two in separate pictures. Similarly, you could feed it a picture of a cat with your neighbours&#8217; annoying dog on it, and ask it to remove the dog, without ever having done such an operation. Demo&#8217;s have shown that these networks can also learn to model complex transformations on images, such as changing the source of light or the rotation of a 3D object. These networks tend to be trained with back-propagation.</p>
<p><i>Kulkarni, Tejas D., et al. &#8220;Deep convolutional inverse graphics network.&#8221; Advances in Neural Information Processing Systems. 2015.</i><br />
<a style="color:#06c" href="https://arxiv.org/pdf/1503.03167v4.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/gan.png" width="300" /></p>
<p><strong>Generative adversarial networks (GAN)</strong> are from a different breed of networks, they are twins: two networks working together. GANs consist of any two networks (although often a combination of FFs and CNNs), with one tasked to generate content and the other has to judge content. The discriminating network receives either training data or generated content from the generative network. How well the discriminating network was able to correctly predict the data source is then used as part of the error for the generating network. This creates a form of competition where the discriminator is getting better at distinguishing real data from generated data and the generator is learning to become less predictable to the discriminator. This works well in part because even quite complex noise-like patterns are eventually predictable but generated content similar in features to the input data is harder to learn to distinguish. GANs can be quite difficult to train, as you don&#8217;t just have to train two networks (either of which can pose it&#8217;s own problems) but their dynamics need to be balanced as well. If prediction or generation becomes to good compared to the other, a GAN won&#8217;t converge as there is intrinsic divergence.</p>
<p><i>Goodfellow, Ian, et al. &#8220;Generative adversarial nets.&#8221; Advances in Neural Information Processing Systems. 2014.</i><br />
<a style="color:#06c" href="https://arxiv.org/pdf/1406.2661v1.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/rnn.png" width="300" /></p>
<p><strong>Recurrent neural networks (RNN)</strong> are FFNNs with a time twist: they are not stateless; they have connections between passes, connections through time. Neurons are fed information not just from the previous layer but also from themselves from the previous pass. This means that the order in which you feed the input and train the network matters: feeding it &#8220;milk&#8221; and then &#8220;cookies&#8221; may yield different results compared to feeding it &#8220;cookies&#8221; and then &#8220;milk&#8221;. One big problem with RNNs is the vanishing (or exploding) gradient problem where, depending on the activation functions used, information rapidly gets lost over time, just like very deep FFNNs lose information in depth. Intuitively this wouldn&#8217;t be much of a problem because these are just weights and not neuron states, but the weights through time is actually where the information from the past is stored; if the weight reaches a value of 0 or 1 000 000, the previous state won&#8217;t be very informative. RNNs can in principle be used in many fields as most forms of data that don&#8217;t actually have a timeline (i.e. unlike sound or video) can be represented as a sequence. A picture or a string of text can be fed one pixel or character at a time, so the time dependent weights are used for what came before in the sequence, not actually from what happened x seconds before. In general, recurrent networks are a good choice for advancing or completing information, such as autocompletion.</p>
<p><i>Elman, Jeffrey L. &#8220;Finding structure in time.&#8221; Cognitive science 14.2 (1990): 179-211.</i><br />
<a style="color:#06c" href="https://crl.ucsd.edu/~elman/Papers/fsit.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/lstm.png" width="300" /></p>
<p><strong>Long / short term memory (LSTM)</strong> networks try to combat the vanishing / exploding gradient problem by introducing gates and an explicitly defined memory cell. These are inspired mostly by circuitry, not so much biology. Each neuron has a memory cell and three gates: input, output and forget. The function of these gates is to safeguard the information by stopping or allowing the flow of it. The input gate determines how much of the information from the previous layer gets stored in the cell. The output layer takes the job on the other end and determines how much of the next layer gets to know about the state of this cell. The forget gate seems like an odd inclusion at first but sometimes it&#8217;s good to forget: if it&#8217;s learning a book and a new chapter begins, it may be necessary for the network to forget some characters from the previous chapter. LSTMs have been shown to be able to learn complex sequences, such as writing like Shakespeare or composing primitive music. Note that each of these gates has a weight to a cell in the previous neuron, so they typically require more resources to run.</p>
<p><i>Hochreiter, Sepp, and Jürgen Schmidhuber. &#8220;Long short-term memory.&#8221; Neural computation 9.8 (1997): 1735-1780.</i><br />
<a style="color:#06c" href="http://deeplearning.cs.cmu.edu/pdfs/Hochreiter97_lstm.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/gru.png" width="300" /></p>
<p><strong>Gated recurrent units (GRU)</strong> are a slight variation on LSTMs. They have one less gate and are wired slightly differently: instead of an input, output and a forget gate, they have an update gate. This update gate determines both how much information to keep from the last state and how much information to let in from the previous layer. The reset gate functions much like the forget gate of an LSTM but it&#8217;s located slightly differently. They always send out their full state, they don&#8217;t have an output gate. In most cases, they function very similarly to LSTMs, with the biggest difference being that GRUs are slightly faster and easier to run (but also slightly less expressive). In practice these tend to cancel each other out, as you need a bigger network to regain some expressiveness which then in turn cancels out the performance benefits. In some cases where the extra expressiveness is not needed, GRUs can outperform LSTMs.</p>
<p><i>Chung, Junyoung, et al. &#8220;Empirical evaluation of gated recurrent neural networks on sequence modeling.&#8221; arXiv preprint arXiv:1412.3555 (2014).</i><br />
<a style="color:#06c" href="https://arxiv.org/pdf/1412.3555v1.pdf">Original Paper PDF</a></p>
<hr />
<p>&nbsp;</p>
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/ntm.png" width="300" /></p>
<p><strong>Neural Turing machines (NTM)</strong> can be understood as an abstraction of LSTMs and an attempt to un-black-box neural networks (and give us some insight in what is going on in there). Instead of coding a memory cell directly into a neuron, the memory is separated. It&#8217;s an attempt to combine the efficiency and permanency of regular digital storage and the efficiency and expressive power of neural networks. The idea is to have a content-addressable memory bank and a neural network that can read and write from it. The &#8220;Turing&#8221; in Neural Turing Machines comes from them being Turing complete: the ability to read and write and change state based on what it reads means it can represent anything a Universal Turing Machine can represent.</p>
<p><i>Graves, Alex, Greg Wayne, and Ivo Danihelka. &#8220;Neural turing machines.&#8221; arXiv preprint arXiv:1410.5401 (2014).</i><br />
<a style="color:#06c" href="https://arxiv.org/pdf/1410.5401v2.pdf">Original Paper PDF</a></p>
<hr />
<p><strong>Bidirectional recurrent neural networks, bidirectional long / short term memory networks and bidirectional gated recurrent units (BiRNN, BiLSTM and BiGRU respectively)</strong> are not shown on the chart because they look exactly the same as their unidirectional counterparts. The difference is that these networks are not just connected to the past, but also to the future. As an example, unidirectional LSTMs might be trained to predict the word &#8220;fish&#8221; by being fed the letters one by one, where the recurrent connections through time remember the last value. A BiLSTM would also be fed the next letter in the sequence on the backward pass, giving it access to future information. This trains the network to fill in gaps instead of advancing information, so instead of expanding an image on the edge, it could fill a hole in the middle of an image.</p>
<p><i>Schuster, Mike, and Kuldip K. Paliwal. &#8220;Bidirectional recurrent neural networks.&#8221; IEEE Transactions on Signal Processing 45.11 (1997): 2673-2681.</i><br />
<a style="color:#06c" href="http://www.di.ufpe.br/~fnj/RNA/bibliografia/BRNN.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/drn.png" width="300" /></p>
<p><strong>Deep residual networks (DRN)</strong> are very deep FFNNs with extra connections passing input from one layer to a later layer (often 2 to 5 layers) as well as the next layer. Instead of trying to find a solution for mapping some input to some output across say 5 layers, the network is enforced to learn to map some input to some output + some input. Basically, it adds an identity to the solution, carrying the older input over and serving it freshly to a later layer. It has been shown that these networks are very effective at learning patterns up to 150 layers deep, much more than the regular 2 to 5 layers one could expect to train. However, it has been proven that these networks are in essence just RNNs without the explicit time based construction and they&#8217;re often compared to LSTMs without gates.</p>
<p><i>He, Kaiming, et al. &#8220;Deep residual learning for image recognition.&#8221; arXiv preprint arXiv:1512.03385 (2015).</i><br />
<a style="color:#06c" href="https://arxiv.org/pdf/1512.03385v1.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/esn.png" width="300" /></p>
<p><strong>Echo state networks (ESN)</strong> are yet another different type of (recurrent) network. This one sets itself apart from others by having random connections between the neurons (i.e. not organised into neat sets of layers), and they are trained differently. Instead of feeding input and back-propagating the error, we feed the input, forward it and update the neurons for a while, and observe the output over time. The input and the output layers have a slightly unconventional role as the input layer is used to prime the network and the output layer acts as an observer of the activation patterns that unfold over time. During training, only the connections between the observer and the (soup of) hidden units are changed.</p>
<p><i>Jaeger, Herbert, and Harald Haas. &#8220;Harnessing nonlinearity: Predicting chaotic systems and saving energy in wireless communication.&#8221; science 304.5667 (2004): 78-80.</i><br />
<a style="color:#06c" href="https://pdfs.semanticscholar.org/8922/17bb82c11e6e2263178ed20ac23db6279c7a.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/elm.png" width="300" /></p>
<p><strong>Extreme learning machines (ELM)</strong> are basically FFNNs but with random connections. They look very similar to LSMs and ESNs, but they are not recurrent nor spiking. They also do not use backpropagation. Instead, they start with random weights and train the weights in a single step according to the least-squares fit (lowest error across all functions). This results in a much less expressive network but it&#8217;s also much faster than backpropagation.</p>
<p><i>Cambria, Erik, et al. &#8220;Extreme learning machines [trends &#038; controversies].&#8221; IEEE Intelligent Systems 28.6 (2013): 30-59.</i><br />
<a style="color:#06c" href="http://www.ntu.edu.sg/home/egbhuang/pdf/ieee-is-elm.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/lsm.png" width="300" /></p>
<p><strong>Liquid state machines (LSM)</strong> are similar soups, looking a lot like ESNs. The real difference is that LSMs are a type of spiking neural networks: sigmoid activations are replaced with threshold functions and each neuron is also an accumulating memory cell. So when updating a neuron, the value is not set to the sum of the neighbours, but rather added to itself. Once the threshold is reached, it releases its&#8217; energy to other neurons. This creates a spiking like pattern, where nothing happens for a while until a threshold is suddenly reached.</p>
<p><i>Maass, Wolfgang, Thomas Natschläger, and Henry Markram. &#8220;Real-time computing without stable states: A new framework for neural computation based on perturbations.&#8221; Neural computation 14.11 (2002): 2531-2560.</i><br />
<a style="color:#06c" href="https://web.archive.org/web/20120222154641/http://ramsesii.upf.es/seminar/Maass_et_al_2002.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/svm.png" width="300" /></p>
<p><strong>Support vector machines (SVM)</strong> find optimal solutions for classification problems. Classically they were only capable of categorising linearly separable data; say finding which images are of Garfield and which of Snoopy, with any other outcome not being possible. During training, SVMs can be thought of as plotting all the data (Garfields and Snoopys) on a graph (2D) and figuring out how to draw a line between the data points. This line would separate the data, so that all Snoopys are on one side and the Garfields on the other. This line moves to an optimal line in such a way that the margins between the data points and the line are maximised on both sides. Classifying new data would be done by plotting a point on this graph and simply looking on which side of the line it is (Snoopy side or Garfield side). Using the kernel trick, they can be taught to classify n-dimensional data. This entails plotting points in a 3D plot, allowing it to distinguish between Snoopy, Garfield AND Simon&#8217;s cat, or even higher dimensions distinguishing even more cartoon characters. SVMs are not always considered neural networks.</p>
<p><i>Cortes, Corinna, and Vladimir Vapnik. &#8220;Support-vector networks.&#8221; Machine learning 20.3 (1995): 273-297.</i><br />
<a style="color:#06c" href="http://image.diku.dk/imagecanon/material/cortes_vapnik95.pdf">Original Paper PDF</a></p>
<hr />
<p><img class="alignnone size-full wp-image-198" src="http://www.asimovinstitute.org/wp-content/uploads/2016/09/kn.png" width="300" /></p>
<p>And finally, <strong>Kohonen networks (KN, also self organising (feature) map, SOM, SOFM)</strong> &#8220;complete&#8221; our zoo. KNs utilise competitive learning to classify data without supervision. Input is presented to the network, after which the network assesses which of its neurons most closely match that input. These neurons are then adjusted to match the input even better, dragging along their neighbours in the process. How much the neighbours are moved depends on the distance of the neighbours to the best matching units. KNs are sometimes not considered neural networks either.</p>
<p><i>Kohonen, Teuvo. &#8220;Self-organized formation of topologically correct feature maps.&#8221; Biological cybernetics 43.1 (1982): 59-69.</i><br />
<a style="color:#06c" href="http://cioslab.vcu.edu/alg/Visualize/kohonen-82.pdf">Original Paper PDF</a></p>
<hr />
<p>Any feedback and criticism is welcome. At the Asimov Institute we do deep learning research and development, so be sure to follow us on <a style="color: #06c;" href="http://www.twitter.com/asimovinstitute" target="_blank">twitter</a> for future updates and posts! Thank you for reading!</p>
<p><span style="color: #666;">[UPDATE 15 sept 2016] I would like to thank everybody for their insights and corrections, all feedback is hugely appreciated. I will add links and a couple more suggested networks in a future update, stay tuned.</span></p>
<p><span style="color: #666;">[UPDATE 29 sept 2016] Added links and citations to all the original papers. A follow up post is planned, since I found at least 9 more architectures. I will not include them in this post for better consistency in terms of content.</span></p>



<p><a href="http://www.asimovinstitute.org/wp-content/uploads/2016/09/networkZooPoster.png">Click here for a high res version of the full image.</a></p>
<div class="addtoany_share_save_container addtoany_content_bottom"><div class="a2a_kit a2a_kit_size_32 addtoany_list" data-a2a-url="http://www.asimovinstitute.org/neural-network-zoo/" data-a2a-title="The Neural Network Zoo"><a class="a2a_button_facebook" href="https://www.addtoany.com/add_to/facebook?linkurl=http%3A%2F%2Fwww.asimovinstitute.org%2Fneural-network-zoo%2F&amp;linkname=The%20Neural%20Network%20Zoo" title="Facebook" rel="nofollow" target="_blank"></a><a class="a2a_button_twitter" href="https://www.addtoany.com/add_to/twitter?linkurl=http%3A%2F%2Fwww.asimovinstitute.org%2Fneural-network-zoo%2F&amp;linkname=The%20Neural%20Network%20Zoo" title="Twitter" rel="nofollow" target="_blank"></a><a class="a2a_button_google_plus" href="https://www.addtoany.com/add_to/google_plus?linkurl=http%3A%2F%2Fwww.asimovinstitute.org%2Fneural-network-zoo%2F&amp;linkname=The%20Neural%20Network%20Zoo" title="Google+" rel="nofollow" target="_blank"></a><a class="a2a_button_reddit" href="https://www.addtoany.com/add_to/reddit?linkurl=http%3A%2F%2Fwww.asimovinstitute.org%2Fneural-network-zoo%2F&amp;linkname=The%20Neural%20Network%20Zoo" title="Reddit" rel="nofollow" target="_blank"></a><a class="a2a_button_linkedin" href="https://www.addtoany.com/add_to/linkedin?linkurl=http%3A%2F%2Fwww.asimovinstitute.org%2Fneural-network-zoo%2F&amp;linkname=The%20Neural%20Network%20Zoo" title="LinkedIn" rel="nofollow" target="_blank"></a></div></div>					</div>
